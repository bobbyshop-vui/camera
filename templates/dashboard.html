<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dashboard</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/js/bootstrap.bundle.min.js"></script>
    <script src="https://cdn.socket.io/4.0.0/socket.io.min.js"></script>
</head>
<body>
    <div class="container">
        <h1 class="my-4">Dashboard</h1>

        <p><strong>ID Ng∆∞·ªùi D√πng:</strong> {{ session['user_id'] }}</p>

        <div class="mb-4">
            <a href="/add_device" class="btn btn-success">Th√™m thi·∫øt b·ªã</a>
            <a href="{{ url_for('logout') }}">ƒêƒÉng xu·∫•t</a>
        </div>

        <h3>Danh s√°ch thi·∫øt b·ªã</h3>
        <ul class="list-group">
            {% for device in devices %}
                <li class="list-group-item">
                    <h5>{{ device.device_id }}</h5>
                    <button class="btn btn-info start-stream" data-device-id="{{ device.device_id }}">
                        Xem camera
                    </button>
                </li>
            {% endfor %}
        </ul>

        <div id="stream-container" class="my-4" style="display:none;">
            <video id="remote-video" width="640" height="360" autoplay playsinline></video>
        </div>

        <div id="camera-container" class="my-4" style="display:none;">
            <h4>Camera ƒëang ph√°t tr·ª±c ti·∫øp</h4>
            <video id="local-video" width="640" height="360" autoplay muted playsinline></video>
        </div>
    </div>

    <script>
        const socket = io.connect('https://' + document.domain + ':' + location.port);
        const userId = {{ session['user_id'] }};
        const localVideo = document.getElementById('local-video');
        const remoteVideo = document.getElementById('remote-video');
        const streamContainer = document.getElementById('stream-container');
        const cameraContainer = document.getElementById('camera-container');

        const peerConnections = {};
        let currentDeviceId = null;
        let currentCameraId = null;

        const iceServers = {
            iceServers: [{ urls: 'stun:stun.l.google.com:19302' }]
        };

        document.querySelectorAll('.start-stream').forEach(button => {
            button.addEventListener('click', () => {
                const deviceId = button.getAttribute('data-device-id');
                currentDeviceId = deviceId;
                startViewerStream(deviceId);
                socket.emit('notify_view_camera', { device_id: deviceId, viewer_id: userId });
            });
        });

        function getPeerConnection(deviceId) {
            if (!peerConnections[deviceId]) {
                peerConnections[deviceId] = new RTCPeerConnection(iceServers);

                peerConnections[deviceId].onicecandidate = event => {
                    if (event.candidate && currentCameraId) {
                        socket.emit('candidate', {
                            candidate: event.candidate,
                            room: deviceId,
                            target_id: currentCameraId
                        });
                    }
                };

                peerConnections[deviceId].ontrack = event => {
                    remoteVideo.srcObject = event.streams[0];
                };
                peerConnections[deviceId].ontrack = event => {
                    console.log(`‚úÖ Nh·∫≠n track t·ª´ thi·∫øt b·ªã ${deviceId}`, event.streams[0]);
                    remoteVideo.srcObject = event.streams[0];
                };
            }
            return peerConnections[deviceId];
        }

        async function startViewerStream(deviceId) {
            console.log(`üì∫ B·∫Øt ƒë·∫ßu xem stream t·ª´ thi·∫øt b·ªã ${deviceId}`);
            streamContainer.style.display = 'block';
            cameraContainer.style.display = 'none';

            const pc = getPeerConnection(deviceId);

            socket.emit('start_stream', { device_id: deviceId, viewer_id: userId });

            socket.off('offer');
            socket.off('candidate');

            socket.on('offer', (data) => {
                console.log('Received offer:', data);

                const pc = new RTCPeerConnection(iceServers);
                pc.setRemoteDescription(new RTCSessionDescription(data.sdp))
                    .then(() => pc.createAnswer())
                    .then(answer => {
                        return pc.setLocalDescription(answer);
                    })
                    .then(() => {
                        console.log('Sending answer back:', pc.localDescription);
                        socket.emit('offer', {
                            sdp: pc.localDescription,
                            room: deviceId,
                            sender_id: userId
                        });
                    })
                    .catch(console.error);
                    socket.emit('answer', {
                        sdp: pc.localDescription,
                        room: data.room,
                        target_id: data.sender_id
                    });
            });
            socket.on('candidate', (data) => {
                if (data.room === deviceId) {
                    pc.addIceCandidate(new RTCIceCandidate(data.candidate));
                }
            });
        }

        async function startCameraStream(deviceId) {
            try {
                console.log(`üìπ B·∫Øt ƒë·∫ßu ph√°t camera t·ª´ thi·∫øt b·ªã ${deviceId}`);

                const stream = await navigator.mediaDevices.getUserMedia({ video: true, audio: false });
                localVideo.srcObject = stream;
                cameraContainer.style.display = 'block';
                streamContainer.style.display = 'none';

                const pc = getPeerConnection(deviceId);
                stream.getTracks().forEach(track => pc.addTrack(track, stream));

                const offer = await pc.createOffer();
                await pc.setLocalDescription(offer);

                socket.emit('offer', {
                    sdp: pc.localDescription,
                    room: deviceId,
                    sender_id: userId
                });

                socket.off('answer');
                socket.off('candidate');

                socket.on('answer', async (data) => {
                    if (data.room === deviceId) {
                        await pc.setRemoteDescription(new RTCSessionDescription(data.sdp));
                    }
                });

                socket.on('candidate', (data) => {
                    if (data.room === deviceId) {
                        pc.addIceCandidate(new RTCIceCandidate(data.candidate));
                    }
                });

            } catch (err) {
                console.error('‚ùå Kh√¥ng th·ªÉ m·ªü camera:', err);
            }
        }

        socket.on('register_camera_command', (data) => {
            const deviceId = data.device_id;
            console.log(`üìπ Server y√™u c·∫ßu ƒëƒÉng k√Ω camera cho thi·∫øt b·ªã: ${deviceId}`);
            registerAsCamera(deviceId);
        });

        function registerAsCamera(deviceId) {
            socket.emit('register_device', { user_id: userId, device_id: deviceId });

            socket.once('device_status', (data) => {
                if (data.device_id === deviceId) {
                    if (data.is_camera) {
                        startCameraStream(deviceId);
                    } else {
                        alert(data.error || '‚ùå Thi·∫øt b·ªã kh√¥ng ph·∫£i camera ho·∫∑c kh√¥ng s·∫µn s√†ng.');
                    }
                }
            });
        }

        socket.on('start_stream_request', (data) => {
            console.log(`üìπ Nh·∫≠n y√™u c·∫ßu ph√°t camera t·ª´ server (cho viewer ${data.viewer_id})`);
            startCameraStream(data.device_id);
        });

        document.addEventListener('DOMContentLoaded', () => {
            console.log("‚úÖ Dashboard ƒë√£ t·∫£i v√† k·∫øt n·ªëi socket th√†nh c√¥ng.");
        });
    </script>
</body>
</html>
